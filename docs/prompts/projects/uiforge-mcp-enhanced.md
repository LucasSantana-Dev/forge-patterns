# UIForge MCP Enhanced Prompts

Skill-enhanced prompt templates for UIForge MCP development, integrating Vercel composition patterns, systematic debugging, MCP docs search, and brainstorming capabilities.

## üèóÔ∏è Service Layer Architecture Prompts

### **Service Layer Refactoring**
```markdown
# Service Layer Refactoring
You are a Node.js/TypeScript specialist working on the UIForge MCP. The [service/module] needs [refactoring/optimization].

SERVICE LAYER PATTERNS:
- Apply @[/vercel-composition-patterns] for maintainable services
- Use @[/systematic-debugging] for architecture troubleshooting
- Apply @[/get-context] for current service state
- Use @[/skill-mcp-docs-search] for Node.js patterns

BRAINSTORMING REFACTORING APPROACH:
1. Analyze current service layer challenges and coupling issues
2. Explore refactoring opportunities:
   - Extract shared logic into dedicated services
   - Implement dependency injection patterns
   - Create proper service boundaries
   - Establish clear interfaces and contracts
3. Design enhanced service architecture
4. Plan incremental refactoring strategy

REFACTORING METHODOLOGY:
‚úÖ SERVICE ANALYSIS:
- [ ] Identify coupling issues and dependencies
- [ ] Extract shared logic into dedicated services
- [ ] Implement dependency injection
- [ ] Create comprehensive test coverage

‚úÖ ARCHITECTURE PATTERNS:
- [ ] Apply composition over inheritance
- [ ] Use factory patterns for service creation
- [ ] Implement proper error boundaries
- [ ] Create clear service interfaces

‚úÖ DEPENDENCY MANAGEMENT:
- [ ] Implement inversion of control
- [ ] Use dependency injection containers
- [ ] Create proper service lifecycles
- [ ] Handle service discovery and registration

COMPOSITION PATTERNS APPLICATION:
‚úÖ MAINTAINABLE SERVICES:
- [ ] Use compound services instead of boolean configuration
- [ ] Create explicit service variants
- [ ] Implement proper service composition
- [ ] Apply dependency injection patterns

‚úÖ STATE MANAGEMENT:
- [ ] Use context providers for shared state
- [ ] Implement proper error handling
- [ ] Create efficient state update patterns
- [ ] Handle side effects appropriately

‚úÖ PERFORMANCE OPTIMIZATION:
- [ ] Apply service caching strategies
- [ ] Implement proper connection pooling
- [ ] Use efficient data structures
- [ ] Optimize service communication patterns

SYSTEMATIC DEBUGGING:
- Use @[/systematic-debugging] for service troubleshooting
- Read error messages completely and identify patterns
- Reproduce issues consistently with test cases
- Check recent changes that could cause issues
- Test minimal fixes before full implementation

MCP ENHANCEMENT:
- Use @[/get-context] for current service architecture
- Apply @[/skill-mcp-docs-search] for service patterns
- Validate with @[/mcp-docs-and-tools] for Node.js best practices
```

### **Generator Factory Enhancement**
```markdown
# Generator Factory Optimization
You are working on the UIForge MCP generator factory. The [generator/framework] needs [enhancement/optimization].

GENERATOR FACTORY PATTERNS:
- Apply @[/vercel-composition-patterns] for flexible generators
- Use @[/systematic-debugging] for generator troubleshooting
- Apply @[/get-context] for current generator state
- Use @[/skill-mcp-docs-search] for generator patterns

BRAINSTORMING GENERATOR IMPROVEMENTS:
1. Analyze current generator challenges and limitations
2. Explore enhancement opportunities:
   - Improved template system architecture
   - Enhanced framework parity
   - Better error handling and validation
   - Advanced customization options
3. Design enhanced generator architecture
4. Plan implementation with testing strategy

GENERATOR ENHANCEMENT STANDARDS:
‚úÖ FACTORY PATTERN:
- [ ] Use dependency injection for generator creation
- [ ] Create explicit variant generators
- [ ] Apply composition over inheritance
- [ ] Implement proper error handling

‚úÖ FRAMEWORK PARITY:
- [ ] Maintain consistency across all frameworks
- [ ] Apply framework-specific optimizations
- [ ] Test all generator outputs thoroughly
- [ ] Document template variations

‚úÖ TEMPLATE SYSTEM:
- [ ] Design flexible template architecture
- [ ] Implement template inheritance and composition
- [ ] Create template validation and testing
- [ ] Add template customization capabilities

COMPOSITION PATTERNS:
‚úÖ FLEXIBLE GENERATORS:
- [ ] Use compound generators instead of boolean flags
- [ ] Create explicit generator variants
- [ ] Implement proper generator composition
- [ ] Apply dependency injection for generator dependencies

‚úÖ CUSTOMIZATION SUPPORT:
- [ ] Design extensible generator architecture
- [ ] Implement plugin system for custom generators
- [ ] Create configuration-driven generation
- [ ] Support user-defined templates and patterns

‚úÖ ERROR HANDLING:
- [ ] Implement comprehensive error validation
- [ ] Create helpful error messages and suggestions
- [ ] Add graceful degradation for unsupported features
- [ ] Provide debugging information for generator issues

SYSTEMATIC DEBUGGING:
- Use @[/systematic-debugging] for generator troubleshooting
- Read error messages completely and identify patterns
- Reproduce generation issues consistently
- Check recent template or configuration changes
- Test minimal fixes before full implementation

FRAMEWORK SPECIFICS:
‚úÖ REACT GENERATOR:
- [ ] Implement modern React patterns (hooks, functional components)
- [ ] Add TypeScript support and type generation
- [ ] Create component testing templates
- [ ] Support React 19 and Next.js patterns

‚úÖ VUE GENERATOR:
- [ ] Implement Vue 3 Composition API patterns
- [ ] Add TypeScript support and type generation
- [ ] Create component testing templates
- [ ] Support Vue ecosystem integration

‚úÖ ANGULAR GENERATOR:
- [ ] Implement modern Angular patterns
- [ ] Add TypeScript support and type generation
- [ ] Create service and component templates
- [ ] Support Angular ecosystem integration

‚úÖ SVELTE GENERATOR:
- [ ] Implement Svelte 5 patterns and runes
- [ ] Add TypeScript support and type generation
- [ ] Create component testing templates
- [ ] Support Svelte ecosystem integration

MCP ENHANCEMENT:
- Use @[/get-context] for current generator factory state
- Apply @[/skill-mcp-docs-search] for generator patterns
- Validate with @[/mcp-docs-and-tools] for template best practices
```

## ü§ñ ML Pipeline Integration Prompts

### **ML Pipeline Enhancement**
```markdown
# ML Pipeline Enhancement
You are enhancing the UIForge MCP ML pipeline. The [component/feature] needs [improvement/optimization].

ML PIPELINE SYSTEMATIC APPROACH:
- Use @[/systematic-debugging] for ML troubleshooting
- Apply @[/brainstorming] for ML innovation
- Use @[/skill-mcp-docs-search] for ML patterns

BRAINSTORMING ML IMPROVEMENTS:
1. Analyze current ML pipeline challenges and bottlenecks
2. Explore enhancement opportunities:
   - Improved embedding generation and similarity
   - Enhanced prompt classification and routing
   - Better ML model integration and optimization
   - Advanced analytics and learning capabilities
3. Design enhanced ML pipeline architecture
4. Plan implementation with testing strategy

ML PIPELINE STANDARDS:
‚úÖ EMBEDDING OPTIMIZATION:
- [ ] Implement efficient embedding generation
- [ ] Add embedding caching and persistence
- [ ] Create similarity search optimization
- [ ] Design embedding update strategies

‚úÖ PROMPT CLASSIFICATION:
- [ ] Enhance prompt classification accuracy
- [ ] Implement multi-label classification
- [ ] Add confidence scoring and thresholding
- [ ] Create classification model training pipeline

‚úÖ MODEL INTEGRATION:
- [ ] Optimize model inference performance
- [ ] Implement model versioning and updates
- [ ] Add model monitoring and drift detection
- [ ] Create A/B testing for model improvements

SYSTEMATIC DEBUGGING:
- Use @[/systematic-debugging] for ML troubleshooting
- Read error messages completely and identify patterns
- Reproduce ML issues consistently with test cases
- Check recent model or data changes
- Test minimal fixes before full implementation

ML SPECIFICS:
‚úÖ DATA PROCESSING:
- [ ] Implement efficient data preprocessing
- [ ] Add data validation and cleaning
- [ ] Create feature engineering pipelines
- [ ] Handle data versioning and lineage

‚úÖ MODEL TRAINING:
- [ ] Design automated training pipelines
- [ ] Implement hyperparameter optimization
- [ ] Add model evaluation and validation
- [ ] Create model deployment strategies

‚úÖ INFERENCE OPTIMIZATION:
- [ ] Optimize model inference latency
- [ ] Implement batch processing capabilities
- [ ] Add model caching and preloading
- [ ] Create load balancing for model serving

SERVICE INTEGRATION:
- Apply @[/vercel-composition-patterns] for ML services
- Use proper service boundaries and interfaces
- Implement dependency injection for ML components
- Create comprehensive error handling and recovery

MCP ENHANCEMENT:
- Use @[/get-context] for current ML pipeline state
- Apply @[/skill-mcp-docs-search] for ML patterns
- Validate with @[/mcp-docs-and-tools] for ML best practices
```

## üîß MCP Tool Development Prompts

### **MCP Tool Implementation**
```markdown
# MCP Tool Implementation
You are implementing a new MCP tool for the UIForge MCP. Create [tool] with [functionality/requirements].

MCP TOOL SYSTEMATIC APPROACH:
- Use @[/systematic-debugging] for tool development
- Apply @[/brainstorming] for tool innovation
- Use @[/skill-mcp-docs-search] for MCP patterns

BRAINSTORMING TOOL DESIGN:
1. Analyze tool requirements and user needs
2. Explore tool design opportunities:
   - Innovative tool functionality and features
   - Improved user experience and interface
   - Better integration with existing tools
   - Advanced capabilities and automation
3. Design comprehensive tool architecture
4. Plan implementation with testing strategy

MCP TOOL STANDARDS:
‚úÖ TOOL ARCHITECTURE:
- [ ] Implement proper MCP tool interface
- [ ] Create comprehensive tool documentation
- [ ] Add tool validation and error handling
- [ ] Design tool configuration and options

‚úÖ FUNCTIONALITY IMPLEMENTATION:
- [ ] Implement core tool functionality
- [ ] Add comprehensive parameter validation
- [ ] Create helpful error messages and suggestions
- [ ] Design intuitive tool interface

‚úÖ INTEGRATION PATTERNS:
- [ ] Integrate with existing MCP infrastructure
- [ ] Use proper service dependencies
- [ ] Implement tool discovery and registration
- [ ] Create tool testing and validation

SYSTEMATIC DEBUGGING:
- Use @[/systematic-debugging] for tool troubleshooting
- Read error messages completely and identify patterns
- Reproduce tool issues consistently with test cases
- Check recent code or configuration changes
- Test minimal fixes before full implementation

SERVICE LAYER INTEGRATION:
- Apply @[/vercel-composition-patterns] for tool services
- Use proper service boundaries and interfaces
- Implement dependency injection for tool components
- Create comprehensive error handling and recovery

TOOL SPECIFICS:
‚úÖ PARAMETER HANDLING:
- [ ] Implement comprehensive parameter validation
- [ ] Add parameter type checking and conversion
- [ ] Create helpful parameter documentation
- [ ] Handle parameter defaults and options

‚úÖ ERROR HANDLING:
- [ ] Implement comprehensive error handling
- [ ] Create helpful error messages and recovery suggestions
- [ ] Add error logging and monitoring
- [ ] Design graceful degradation strategies

‚úÖ PERFORMANCE OPTIMIZATION:
- [ ] Optimize tool execution performance
- [ ] Implement caching where appropriate
- [ ] Add resource usage monitoring
- [ ] Create load balancing for high-demand tools

MCP PROTOCOL COMPLIANCE:
- Use @[/get-context] for current MCP implementation
- Apply @[/skill-mcp-docs-search] for MCP patterns
- Validate with @[/mcp-docs-and-tools] for MCP best practices
- Ensure proper MCP protocol compliance

TESTING AND VALIDATION:
- Create comprehensive unit tests
- Implement integration testing with MCP infrastructure
- Add end-to-end testing scenarios
- Create performance and load testing

MCP ENHANCEMENT:
- Use @[/get-context] for current tool ecosystem
- Apply @[/skill-mcp-docs-search] for tool patterns
- Validate with @[/mcp-docs-and-tools] for MCP best practices
```

## üîÑ Framework Parity Maintenance Prompts

### **Framework Parity Enhancement**
```markdown
# Framework Parity Enhancement
You are maintaining framework parity in the UIForge MCP. Ensure [feature/capability] works consistently across [frameworks].

FRAMEWORK PARITY SYSTEMATIC APPROACH:
- Use @[/systematic-debugging] for parity issues
- Apply @[/brainstorming] for parity improvements
- Use @[/skill-mcp-docs-search] for framework patterns

BRAINSTORMING PARITY STRATEGIES:
1. Analyze current parity gaps and inconsistencies
2. Explore parity improvement opportunities:
   - Unified API design across frameworks
   - Consistent feature implementation
   - Framework-specific optimizations
   - Better testing and validation
3. Design comprehensive parity strategy
4. Plan implementation with testing framework

PARITY MAINTENANCE STANDARDS:
‚úÖ API CONSISTENCY:
- [ ] Ensure consistent API design across frameworks
- [ ] Implement unified parameter interfaces
- [ ] Create consistent error handling patterns
- [ ] Design framework-agnostic core logic

‚úÖ FEATURE PARITY:
- [ ] Implement consistent feature sets
- [ ] Add framework-specific optimizations
- [ ] Create comprehensive feature testing
- [ ] Document framework differences and limitations

‚úÖ CODE GENERATION:
- [ ] Ensure consistent code generation patterns
- [ ] Implement framework-specific optimizations
- [ ] Create unified template architecture
- [ ] Add comprehensive generation testing

SYSTEMATIC DEBUGGING:
- Use @[/systematic-debugging] for parity troubleshooting
- Read error messages completely and identify patterns
- Reproduce parity issues consistently
- Check recent framework-specific changes
- Test minimal fixes before full implementation

FRAMEWORK-SPECIFIC IMPLEMENTATION:
‚úÖ REACT PARITY:
- [ ] Implement modern React patterns and features
- [ ] Add React-specific optimizations
- [ ] Ensure TypeScript support and type generation
- [ ] Create React-specific testing strategies

‚úÖ VUE PARITY:
- [ ] Implement Vue 3 Composition API patterns
- [ ] Add Vue-specific optimizations
- [ ] Ensure TypeScript support and type generation
- [ ] Create Vue-specific testing strategies

‚úÖ ANGULAR PARITY:
- [ ] Implement modern Angular patterns and features
- [ ] Add Angular-specific optimizations
- [ ] Ensure TypeScript support and type generation
- [ ] Create Angular-specific testing strategies

‚úÖ SVELTE PARITY:
- [ ] Implement Svelte 5 patterns and features
- [ ] Add Svelte-specific optimizations
- [ ] Ensure TypeScript support and type generation
- [ ] Create Svelte-specific testing strategies

COMPOSITION PATTERNS:
- Apply @[/vercel-composition-patterns] for framework services
- Use consistent service interfaces across frameworks
- Implement proper dependency injection
- Create comprehensive error handling

TESTING FRAMEWORK:
- Create comprehensive parity testing suite
- Implement cross-framework integration tests
- Add performance benchmarking across frameworks
- Create automated parity validation

MCP ENHANCEMENT:
- Use @[/get-context] for current parity state
- Apply @[/skill-mcp-docs-search] for framework patterns
- Validate with @[/mcp-docs-and-tools] for framework best practices
```

## üìä Testing and Quality Assurance Prompts

### **Comprehensive Testing Strategy**
```markdown
# Comprehensive Testing Strategy
You are implementing testing for the UIForge MCP. Create [test suite/strategy] for [component/feature].

TESTING SYSTEMATIC APPROACH:
- Use @[/systematic-debugging] for test troubleshooting
- Apply @[/brainstorming] for testing strategy innovation
- Use @[/skill-mcp-docs-search] for testing patterns

BRAINSTORMING TESTING STRATEGIES:
1. Analyze current testing gaps and challenges
2. Explore testing improvement opportunities:
   - Comprehensive test coverage strategies
   - Automated testing pipelines
   - Performance and load testing
   - Integration and end-to-end testing
3. Design comprehensive testing framework
4. Plan implementation with CI/CD integration

TESTING STANDARDS:
‚úÖ UNIT TESTING:
- [ ] Implement comprehensive unit test coverage
- [ ] Create testable code architecture
- [ ] Add mocking and stubbing strategies
- [ ] Design test data management

‚úÖ INTEGRATION TESTING:
- [ ] Test service layer integration
- [ ] Validate MCP tool interactions
- [ ] Test database and external service integrations
- [ ] Create integration test data management

‚úÖ END-TO-END TESTING:
- [ ] Implement comprehensive E2E test scenarios
- [ ] Test complete user workflows
- [ ] Validate cross-framework functionality
- [ ] Create E2E test environment management

SYSTEMATIC DEBUGGING:
- Use @[/systematic-debugging] for test troubleshooting
- Read test failure messages completely
- Reproduce test failures consistently
- Check recent code changes affecting tests
- Test minimal fixes before full implementation

TESTING PATTERNS:
‚úÖ TEST ARCHITECTURE:
- [ ] Design maintainable test architecture
- [ ] Implement test utilities and helpers
- [ ] Create test configuration management
- [ ] Add test reporting and analytics

‚úÖ TEST AUTOMATION:
- [ ] Implement automated test execution
- [ ] Create continuous integration testing
- [ ] Add automated test reporting
- [ ] Design test result notification

‚úÖ PERFORMANCE TESTING:
- [ ] Implement load testing strategies
- [ ] Create performance benchmarking
- [ ] Add memory and resource testing
- [ ] Design performance regression testing

SERVICE LAYER TESTING:
- Apply @[/vercel-composition-patterns] for test services
- Test service boundaries and interfaces
- Implement dependency injection for testing
- Create comprehensive error handling tests

FRAMEWORK TESTING:
- Test framework parity consistently
- Create framework-specific test suites
- Implement cross-framework validation
- Add framework performance testing

MCP ENHANCEMENT:
- Use @[/get-context] for current testing state
- Apply @[/skill-mcp-docs-search] for testing patterns
- Validate with @[/mcp-docs-and-tools] for testing best practices
```

## üöÄ Performance Optimization Prompts

### **Performance Enhancement Strategy**
```markdown
# Performance Enhancement Strategy
You are optimizing the UIForge MCP performance. Improve [component/metric] for [performance goal].

PERFORMANCE SYSTEMATIC APPROACH:
- Use @[/systematic-debugging] for performance analysis
- Apply @[/brainstorming] for performance optimization
- Use @[/skill-mcp-docs-search] for performance patterns

BRAINSTORMING PERFORMANCE IMPROVEMENTS:
1. Analyze current performance bottlenecks and issues
2. Explore optimization opportunities:
   - Code execution optimization
   - Memory usage optimization
   - I/O and network optimization
   - Caching and data structure optimization
3. Design comprehensive performance improvement plan
4. Plan implementation with monitoring

PERFORMANCE STANDARDS:
‚úÖ CODE OPTIMIZATION:
- [ ] Implement efficient algorithms and data structures
- [ ] Optimize code execution paths
- [ ] Add performance profiling and monitoring
- [ ] Create performance regression testing

‚úÖ MEMORY OPTIMIZATION:
- [ ] Optimize memory usage patterns
- [ ] Implement memory leak detection
- [ ] Add garbage collection optimization
- [ ] Create memory usage monitoring

‚úÖ I/O OPTIMIZATION:
- [ ] Optimize file system operations
- [ ] Implement efficient network communication
- [ ] Add connection pooling and caching
- [ ] Create I/O performance monitoring

SYSTEMATIC DEBUGGING:
- Use @[/systematic-debugging] for performance troubleshooting
- Read performance error messages completely
- Reproduce performance issues consistently
- Check recent changes affecting performance
- Test minimal optimizations before full implementation

SERVICE LAYER OPTIMIZATION:
- Apply @[/vercel-composition-patterns] for performance
- Optimize service communication patterns
- Implement efficient state management
- Create performance-aware service design

ML PIPELINE OPTIMIZATION:
- Optimize model inference performance
- Implement efficient data processing
- Add model caching and preloading
- Create ML performance monitoring

GENERATOR OPTIMIZATION:
- Optimize template processing performance
- Implement efficient code generation
- Add generator caching strategies
- Create generation performance monitoring

MCP TOOL OPTIMIZATION:
- Optimize tool execution performance
- Implement efficient parameter processing
- Add tool result caching
- Create tool performance monitoring

MCP ENHANCEMENT:
- Use @[/get-context] for current performance state
- Apply @[/skill-mcp-docs-search] for performance patterns
- Validate with @[/mcp-docs-and-tools] for optimization best practices
```

## üìù Usage Guidelines

### **For UIForge MCP Development**
1. **Apply Composition Patterns**: Use @[/vercel-composition-patterns] for maintainable services
2. **Use Systematic Debugging**: Apply @[/systematic-debugging] for all troubleshooting
3. **Leverage MCP Knowledge**: Use @[/skill-mcp-docs-search] and @[/mcp-docs-and-tools]
4. **Innovate with Brainstorming**: Apply @[/brainstorming] for design and architecture decisions

### **For Service Layer Development**
1. **Design Maintainable Services**: Use composition over inheritance
2. **Implement Dependency Injection**: Create flexible, testable services
3. **Handle Errors Gracefully**: Implement comprehensive error handling
4. **Optimize Performance**: Apply performance patterns and monitoring

### **For Generator Development**
1. **Ensure Framework Parity**: Maintain consistency across all frameworks
2. **Design Flexible Templates**: Create extensible template systems
3. **Test Thoroughly**: Validate all generator outputs
4. **Document Patterns**: Provide clear documentation and examples

### **For ML Pipeline Development**
1. **Optimize Performance**: Focus on efficient inference and processing
2. **Handle Data Properly**: Implement robust data processing and validation
3. **Monitor Models**: Track model performance and drift
4. **Test Continuously**: Validate ML pipeline end-to-end

These enhanced prompts leverage composition patterns, systematic debugging, MCP expertise, and brainstorming to create robust, maintainable, and innovative MCP server implementations that excel in functionality and performance.