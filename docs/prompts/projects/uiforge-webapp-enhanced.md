# UIForge WebApp Enhanced Prompts

Skill-enhanced prompt templates for UIForge WebApp development, integrating Next.js best practices, Supabase optimization, UI/UX design, and frontend design expertise.

## üöÄ Next.js 16 Development Prompts

### **App Router Implementation**
```markdown
# Next.js 16 App Router Implementation
You are a Next.js specialist working on the UIForge WebApp. Implement [feature/page] with [requirements].

NEXT.JS 16 OPTIMIZED APPROACH:
- Apply @[/next-best-practices] for App Router patterns
- Use @[/vercel-react-best-practices] for performance optimization
- Apply @[/systematic-debugging] for error prevention

IMPLEMENTATION STANDARDS:
‚úÖ FILE CONVENTIONS:
- [ ] Follow Next.js 16 App Router patterns
- [ ] Use proper RSC boundaries (server vs client components)
- [ ] Apply async patterns correctly with Promise.all()
- [ ] Use appropriate directives (use client, use server)

‚úÖ PERFORMANCE OPTIMIZATION:
- [ ] Eliminate waterfalls with parallel data fetching
- [ ] Use next/dynamic for heavy components
- [ ] Apply React.cache() for deduplication
- [ ] Optimize bundle size with tree shaking

‚úÖ ERROR HANDLING:
- [ ] Use proper error boundaries
- [ ] Apply systematic debugging methodology
- [ ] Document error patterns and solutions
- [ ] Create failing test cases before fixes

NEXT.JS SPECIFICS:
‚úÖ ROUTE STRUCTURE:
- [ ] Use file-based routing with proper hierarchy
- [ ] Implement route groups for organization
- [ ] Apply parallel routes for complex layouts
- [ ] Use intercepting routes for modals/overlays

‚úÖ DATA FETCHING:
- [ ] Use async Server Components by default
- [ ] Implement proper caching strategies
- [ ] Apply streaming with Suspense boundaries
- [ ] Use client components only when necessary

‚úÖ PERFORMANCE PATTERNS:
- [ ] Implement partial prerendering when appropriate
- [ ] Use dynamic imports for code splitting
- [ ] Apply proper image optimization
- [ ] Optimize font loading strategies

UI/UX ENHANCEMENT:
- Apply @[/ui-ux-pro-max] for accessibility guidelines
- Use @[/frontend-design] for distinctive visual choices
- Focus on WCAG AAA compliance and professional interfaces

SUPABASE INTEGRATION:
- Apply @[/supabase-postgres-best-practices] for database patterns
- Use RLS policies correctly for security
- Optimize query patterns for performance
- Implement proper authentication flows

MCP ENHANCEMENT:
- Use @[/get-context] for current project state
- Apply @[/skill-mcp-docs-search] for Next.js patterns
- Validate with @[/mcp-docs-and-tools] for best practices
```

### **Component Development with shadcn/ui**
```markdown
# shadcn/ui Component Development
You are creating a [component] for the UIForge WebApp using shadcn/ui. Implement [functionality] with [requirements].

SHADCN/UI OPTIMIZED APPROACH:
- Apply @[/frontend-design] for distinctive aesthetic choices
- Use @[/ui-ux-pro-max] for comprehensive UX guidelines
- Apply @[/vercel-composition-patterns] for maintainable components

COMPONENT DESIGN STANDARDS:
‚úÖ AESTHETIC DIRECTION:
- [ ] Choose bold aesthetic direction (minimalist, brutalist, retro-futuristic)
- [ ] Apply distinctive visual style beyond generic templates
- [ ] Focus on memorable, professional interfaces
- [ ] Create cohesive design language consistency

‚úÖ ACCESSIBILITY EXCELLENCE:
- [ ] Ensure 4.5:1 minimum contrast ratios
- [ ] Implement proper focus management
- [ ] Support keyboard navigation fully
- [ ] Add comprehensive ARIA labels and roles

‚úÖ INTERACTION DESIGN:
- [ ] Design 44x44px minimum touch targets
- [ ] Create clear hover and focus states
- [ ] Implement smooth transitions (150-300ms)
- [ ] Add loading states and user feedback

SHADCN/UI SPECIFICS:
‚úÖ COMPONENT PATTERNS:
- [ ] Follow shadcn/ui composition patterns
- [ ] Use proper TypeScript interfaces
- [ ] Implement controlled component patterns
- [ ] Apply consistent styling with CSS variables

‚úÖ CUSTOMIZATION STRATEGY:
- [ ] Extend base components with custom variants
- [ ] Apply project-specific design tokens
- [ ] Maintain consistency with existing theme
- [ ] Create reusable component compositions

‚úÖ STATE MANAGEMENT:
- [ ] Use React hooks for local state
- [ ] Apply context providers for shared state
- [ ] Implement proper form state management
- [ ] Handle loading and error states gracefully

NEXT.JS INTEGRATION:
- Apply @[/next-best-practices] for component patterns
- Use Server Components when appropriate
- Implement proper client component boundaries
- Optimize for bundle size and performance

SUPABASE INTEGRATION:
- Apply @[/supabase-postgres-best-practices] for data patterns
- Use proper subscription patterns for real-time data
- Implement optimistic updates when appropriate
- Handle authentication state properly

MCP ENHANCEMENT:
- Use @[/get-context] for current component ecosystem
- Apply @[/skill-mcp-docs-search] for shadcn/ui patterns
- Validate with @[/mcp-docs-and-tools] for React best practices
```

## üóÑÔ∏è Supabase Integration Prompts

### **Database Schema Design**
```markdown
# Supabase Database Schema Design
You are designing a database schema for the UIForge WebApp. Create [schema/tables] for [feature/requirements].

SUPABASE-OPTIMIZED APPROACH:
- Apply @[/supabase-postgres-best-practices] for query performance
- Use @[/systematic-debugging] for data flow analysis
- Use @[/get-context] for current database state

DATABASE DESIGN PRINCIPLES:
‚úÖ QUERY PERFORMANCE:
- [ ] Add appropriate indexes based on query patterns
- [ ] Use parallel fetching for independent operations
- [ ] Implement proper caching strategies
- [ ] Avoid N+1 query problems with proper joins

‚úÖ SECURITY & RLS:
- [ ] Implement comprehensive Row Level Security policies
- [ ] Use JWT authentication patterns correctly
- [ ] Apply least privilege principle for permissions
- [ ] Test security boundaries thoroughly

‚úÖ SCHEMA DESIGN:
- [ ] Use appropriate data types and constraints
- [ ] Implement proper relationships with foreign keys
- [ ] Add validation constraints and triggers
- [ ] Document design decisions and patterns

SUPABASE SPECIFICS:
‚úÖ TABLE DESIGN:
- [ ] Use UUID primary keys for security
- [ ] Implement created_at/updated_at timestamps
- [ ] Add proper indexes for foreign keys
- [ ] Use jsonb for flexible schema when needed

‚úÖ RLS POLICIES:
- [ ] Create policies for all table operations
- [ ] Use user-based and role-based access control
- [ ] Implement proper authentication checks
- [ ] Test policies with different user roles

‚úÖ REALTIME INTEGRATION:
- [ ] Enable real-time subscriptions appropriately
- [ ] Design efficient real-time data structures
- [ ] Implement proper subscription management
- [ ] Handle connection state and errors

NEXT.JS INTEGRATION:
- Apply @[/next-best-practices] for data fetching patterns
- Use Server Components for data access
- Implement proper caching with React.cache()
- Handle loading and error states gracefully

UI/UX CONSIDERATIONS:
- Apply @[/ui-ux-pro-max] for data presentation patterns
- Design responsive data displays
- Implement proper loading states
- Create intuitive data interaction patterns

MCP ENHANCEMENT:
- Use @[/get-context] for current database state
- Apply @[/skill-mcp-docs-search] for Supabase patterns
- Validate with @[/mcp-docs-and-tools] for database best practices
```

### **Authentication & Authorization**
```markdown
# Supabase Authentication Implementation
You are implementing authentication for the UIForge WebApp. Create [auth feature] with [requirements].

SUPABASE AUTH OPTIMIZED:
- Apply @[/supabase-postgres-best-practices] for security patterns
- Use @[/systematic-debugging] for auth flow analysis
- Use @[/get-context] for current auth state

AUTHENTICATION STANDARDS:
‚úÖ SECURITY IMPLEMENTATION:
- [ ] Implement proper JWT token handling
- [ ] Use secure session management
- [ ] Apply proper token refresh mechanisms
- [ ] Implement CSRF protection where needed

‚úÖ USER EXPERIENCE:
- [ ] Create seamless login/signup flows
- [ ] Implement proper error handling and feedback
- [ ] Design intuitive password recovery
- [ ] Add social authentication options

‚úÖ AUTHORIZATION PATTERNS:
- [ ] Implement role-based access control
- [ ] Use RLS policies for data access
- [ ] Create proper permission checking
- [ ] Handle authorization errors gracefully

SUPABASE AUTH SPECIFICS:
‚úÖ PROVIDER CONFIGURATION:
- [ ] Configure email authentication properly
- [ ] Set up social providers securely
- [ ] Implement custom providers if needed
- [ ] Handle provider-specific edge cases

‚úÖ CLIENT-SIDE AUTH:
- [ ] Use Supabase auth helpers correctly
- [ ] Implement proper auth state management
- [ ] Handle auth state changes reactively
- [ ] Create auth context providers

‚úÖ SERVER-SIDE AUTH:
- [ ] Implement server-side auth validation
- [ ] Use proper middleware for protected routes
- [ ] Handle auth cookies securely
- [ ] Create API route protection

NEXT.JS INTEGRATION:
- Apply @[/next-best-practices] for auth patterns
- Use middleware for route protection
- Implement proper SSR auth handling
- Create auth-aware Server Components

UI/UX ENHANCEMENT:
- Apply @[/ui-ux-pro-max] for auth interface design
- Create accessible auth forms
- Design clear error states and feedback
- Implement progressive authentication flows

FRONTEND DESIGN:
- Apply @[/frontend-design] for distinctive auth interfaces
- Create memorable login experiences
- Design cohesive auth visual identity
- Implement smooth transitions and micro-interactions

MCP ENHANCEMENT:
- Use @[/get-context] for current auth implementation
- Apply @[/skill-mcp-docs-search] for auth patterns
- Validate with @[/mcp-docs-and-tools] for security best practices
```

## üé® UI/UX Enhancement Prompts

### **Component Design Excellence**
```markdown
# Component Design Excellence
You are designing a [component/page] for the UIForge WebApp. Create [design] with [requirements].

USER-CENTERED DESIGN:
- Apply @[/ui-ux-pro-max] for comprehensive UX guidelines
- Use @[/frontend-design] for distinctive aesthetic choices
- Focus on WCAG AAA compliance and professional interfaces

DESIGN EXECUTION STANDARDS:
‚úÖ AESTHETIC INNOVATION:
- [ ] Choose bold aesthetic direction (avoid generic templates)
- [ ] Apply distinctive visual language and typography
- [ ] Create memorable color palette and spacing system
- [ ] Implement unique interaction patterns

‚úÖ ACCESSIBILITY EXCELLENCE:
- [ ] Ensure 4.5:1 minimum contrast ratios (WCAG AAA)
- [ ] Implement proper focus management and indicators
- [ ] Support comprehensive keyboard navigation
- [ ] Add thorough ARIA labels and screen reader support

‚úÖ INTERACTION DESIGN:
- [ ] Design 44x44px minimum touch targets
- [ ] Create clear hover, focus, and active states
- [ ] Implement smooth transitions (150-300ms)
- [ ] Add comprehensive loading states and feedback

‚úÖ RESPONSIVE MASTERY:
- [ ] Design mobile-first with progressive enhancement
- [ ] Create fluid layouts that work across all devices
- [ ] Implement proper breakpoint strategies
- [ ] Optimize touch interactions for mobile

UI/UX PRO MAX APPLICATION:
‚úÖ ADVANCED PATTERNS:
- [ ] Apply advanced layout techniques (CSS Grid, Flexbox)
- [ ] Implement sophisticated animation and micro-interactions
- [ ] Create intuitive information architecture
- [ ] Design for cognitive load reduction

‚úÖ PROFESSIONAL POLISH:
- [ ] Add subtle details and refinements
- [ ] Implement consistent design language
- [ ] Create cohesive visual hierarchy
- [ ] Apply professional typography and spacing

‚úÖ INNOVATIVE INTERFACES:
- [ ] Break from conventional patterns when appropriate
- [ ] Create unique interaction metaphors
- [ ] Design memorable user experiences
- [ ] Implement cutting-edge UI techniques

FRONTEND DESIGN INTEGRATION:
- Apply @[/frontend-design] principles for visual impact
- Create distinctive brand identity in interfaces
- Design for emotional connection and engagement
- Implement artistic direction with technical precision

NEXT.JS IMPLEMENTATION:
- Apply @[/next-best-practices] for component patterns
- Use proper Server/Client component boundaries
- Implement efficient rendering strategies
- Optimize for performance and user experience

SUPABASE CONSIDERATIONS:
- Apply @[/supabase-postgres-best-practices] for data patterns
- Design for real-time data updates
- Create intuitive data visualization
- Handle loading and error states gracefully

MCP ENHANCEMENT:
- Use @[/get-context] for current design system
- Apply @[/skill-mcp-docs-search] for design patterns
- Validate with @[/mcp-docs-and-tools] for UI best practices
```

### **Design System Implementation**
```markdown
# Design System Implementation
You are implementing a design system for the UIForge WebApp. Create [design tokens/components] with [requirements].

DESIGN SYSTEM EXCELLENCE:
- Apply @[/frontend-design] for distinctive visual identity
- Use @[/ui-ux-pro-max] for comprehensive UX guidelines
- Apply @[/vercel-composition-patterns] for maintainable components

SYSTEM DESIGN STANDARDS:
‚úÖ DESIGN TOKENS:
- [ ] Create comprehensive color system with semantic naming
- [ ] Define typography scale and hierarchy
- [ ] Establish spacing and layout systems
- [ ] Implement consistent elevation and shadow systems

‚úÖ COMPONENT ARCHITECTURE:
- [ ] Design composable component patterns
- [ ] Implement proper variant systems
- [ ] Create consistent interaction patterns
- [ ] Build accessible component foundations

‚úÖ VISUAL IDENTITY:
- [ ] Establish distinctive brand aesthetic
- [ ] Create memorable visual language
- [ ] Design cohesive icon and illustration systems
- [ ] Implement consistent animation and motion

COMPOSITION PATTERNS APPLICATION:
‚úÖ MAINTAINABLE COMPONENTS:
- [ ] Use compound components instead of boolean props
- [ ] Create explicit variant components
- [ ] Implement proper composition APIs
- [ ] Apply dependency injection patterns

‚úÖ STATE MANAGEMENT:
- [ ] Use context providers for shared state
- [ ] Implement proper error boundaries
- [ ] Create efficient state update patterns
- [ ] Handle side effects appropriately

‚úÖ PERFORMANCE OPTIMIZATION:
- [ ] Apply React performance patterns
- [ ] Implement proper memoization strategies
- [ ] Use code splitting effectively
- [ ] Optimize bundle size and loading

FRONTEND DESIGN INTEGRATION:
- Apply @[/frontend-design] principles for visual impact
- Create distinctive, memorable design language
- Design for emotional connection and engagement
- Implement artistic direction with technical precision

UI/UX PRO MAX ENHANCEMENT:
- Apply @[/ui-ux-pro-max] for comprehensive UX guidelines
- Ensure WCAG AAA compliance across all components
- Design for diverse user needs and abilities
- Create intuitive, learnable interfaces

NEXT.JS INTEGRATION:
- Apply @[/next-best-practices] for component patterns
- Use proper Server/Client component boundaries
- Implement efficient CSS-in-JS or styling strategies
- Optimize for performance and developer experience

SUPABASE INTEGRATION:
- Apply @[/supabase-postgres-best-practices] for data patterns
- Design components for real-time data integration
- Create intuitive data visualization components
- Handle loading and error states consistently

MCP ENHANCEMENT:
- Use @[/get-context] for current design system state
- Apply @[/skill-mcp-docs-search] for design system patterns
- Validate with @[/mcp-docs-and-tools] for component architecture
```

## ‚ö° Performance Optimization Prompts

### **Core Web Vitals Optimization**
```markdown
# Core Web Vitals Optimization
You are optimizing the UIForge WebApp for Core Web Vitals. Improve [metric/component] for [performance goal].

PERFORMANCE OPTIMIZED APPROACH:
- Apply @[/vercel-react-best-practices] for performance patterns
- Use @[/next-best-practices] for optimization techniques
- Apply @[/systematic-debugging] for performance analysis

CORE WEB VITALS STANDARDS:
‚úÖ LARGEST CONTENTFUL PAINT (LCP):
- [ ] Optimize image loading with Next.js Image component
- [ ] Implement proper resource prioritization
- [ ] Use efficient caching strategies
- [ ] Minimize server response times

‚úÖ FIRST INPUT DELAY (FID):
- [ ] Minimize JavaScript execution time
- [ ] Implement proper code splitting
- [ ] Reduce main thread work
- [ ] Optimize third-party script loading

‚úÖ CUMULATIVE LAYOUT SHIFT (CLS):
- [ ] Reserve space for dynamic content
- [ ] Implement proper image dimensions
- [ ] Use consistent font loading strategies
- [ ] Avoid insertions above existing content

NEXT.JS PERFORMANCE PATTERNS:
‚úÖ BUNDLE OPTIMIZATION:
- [ ] Use dynamic imports for code splitting
- [ ] Implement proper tree shaking
- [ ] Optimize vendor bundling strategies
- [ ] Use next/dynamic for heavy components

‚úÖ RENDERING OPTIMIZATION:
- [ ] Apply React.cache() for data deduplication
- [ ] Use Server Components by default
- [ ] Implement proper streaming with Suspense
- [ ] Optimize re-render cycles

‚úÖ NETWORK OPTIMIZATION:
- [ ] Implement proper HTTP caching
- [ ] Use CDN strategies effectively
- [ ] Optimize API response patterns
- [ ] Minimize network round trips

REACT PERFORMANCE PATTERNS:
‚úÖ COMPONENT OPTIMIZATION:
- [ ] Use React.memo() for expensive renders
- [ ] Apply useMemo() for expensive calculations
- [ ] Implement useCallback() for stable references
- [ ] Optimize state updates and effects

‚úÖ STATE MANAGEMENT:
- [ ] Minimize state complexity and updates
- [ ] Use efficient state update patterns
- [ ] Implement proper context usage
- [ ] Avoid unnecessary re-renders

SUPABASE PERFORMANCE:
- Apply @[/supabase-postgres-best-practices] for query optimization
- Implement proper database connection pooling
- Use efficient query patterns
- Optimize real-time subscription performance

UI/UX PERFORMANCE:
- Apply @[/ui-ux-pro-max] for performance UX guidelines
- Design for perceived performance
- Implement proper loading states
- Create smooth animations and transitions

MCP ENHANCEMENT:
- Use @[/get-context] for current performance state
- Apply @[/skill-mcp-docs-search] for performance patterns
- Validate with @[/mcp-docs-and-tools] for optimization best practices
```

## üõ†Ô∏è Development Workflow Prompts

### **Systematic Debugging for Next.js**
```markdown
# Systematic Debugging for Next.js
You are troubleshooting the UIForge WebApp. The [component/page/feature] is experiencing [specific issue/error].

NEXT.JS SYSTEMATIC DEBUGGING:
- Apply @[/systematic-debugging] for comprehensive troubleshooting
- Use @[/get-context] for current application state
- Apply @[/skill-mcp-docs-search] for Next.js debugging patterns

DEBUGGING METHODOLOGY:
1. READ ERROR MESSAGES COMPLETELY
   - Capture full error stack traces and context
   - Identify Next.js specific error patterns
   - Note build-time vs runtime errors
   - Document error context and reproduction steps

2. REPRODUCE THE ISSUE CONSISTENTLY
   - Create minimal reproduction case
   - Test in different environments (dev/prod)
   - Identify browser-specific vs server issues
   - Document exact steps and conditions

3. CHECK RECENT CHANGES
   - Review recent commits and deployments
   - Identify dependency updates and conflicts
   - Check configuration changes (next.config.js, etc.)
   - Analyze environmental changes

4. TRACE DATA FLOW
   - Map request/response flow through Next.js
   - Identify Server Component vs Client Component issues
   - Check data fetching and caching patterns
   - Verify routing and middleware interactions

5. TEST MINIMAL FIXES
   - Implement smallest possible change
   - Test fix in isolation
   - Verify fix doesn't break other functionality
   - Document root cause and solution

NEXT.JS SPECIFICS:
‚úÖ ROUTING ISSUES:
- [ ] Check file-based routing configuration
- [ ] Verify middleware and route handlers
- [ ] Test dynamic routing and parameters
- [ ] Analyze route protection and auth

‚úÖ COMPONENT ISSUES:
- [ ] Verify Server/Client component boundaries
- [ ] Check async component patterns
- [ ] Test data fetching and caching
- [ ] Analyze state management issues

‚úÖ BUILD ISSUES:
- [ ] Check TypeScript configuration
- [ ] Verify dependency resolution
- [ ] Test build optimization settings
- [ ] Analyze bundle and asset issues

‚úÖ PERFORMANCE ISSUES:
- [ ] Profile component rendering performance
- [ ] Check memory usage and leaks
- [ ] Analyze bundle size and loading
- [ ] Test Core Web Vitals metrics

SUPABASE INTEGRATION DEBUGGING:
- Apply @[/supabase-postgres-best-practices] for database debugging
- Check RLS policy issues and permissions
- Verify real-time subscription problems
- Test authentication and authorization flows

UI/UX DEBUGGING:
- Apply @[/ui-ux-pro-max] for UX issue identification
- Test accessibility and usability issues
- Verify responsive design problems
- Check interaction design flaws

MCP ENHANCEMENT:
- Use @[/get-context] for comprehensive application analysis
- Apply @[/skill-mcp-docs-search] for Next.js debugging patterns
- Validate solutions with @[/mcp-docs-and-tools]
```

## üìù Usage Guidelines

### **For UIForge WebApp Development**
1. **Apply Next.js Best Practices**: Always use @[/next-best-practices] for file conventions and patterns
2. **Leverage Supabase Optimization**: Apply @[/supabase-postgres-best-practices] for database patterns
3. **Focus on UI/UX Excellence**: Use @[/ui-ux-pro-max] and @[/frontend-design] for distinctive interfaces
4. **Optimize Performance**: Apply @[/vercel-react-best-practices] for performance optimization

### **For Component Development**
1. **Design with Distinction**: Avoid generic templates, create memorable interfaces
2. **Ensure Accessibility**: Meet WCAG AAA compliance across all components
3. **Apply Composition Patterns**: Use @[/vercel-composition-patterns] for maintainable code
4. **Test Thoroughly**: Validate across devices, browsers, and user needs

### **For Database Integration**
1. **Design for Performance**: Apply proper indexing and query optimization
2. **Implement Security**: Use comprehensive RLS policies and proper authentication
3. **Handle Real-time**: Design efficient subscription patterns
4. **Optimize Data Flow**: Use proper caching and fetching strategies

These enhanced prompts leverage Next.js best practices, Supabase optimization, UI/UX design expertise, and frontend design principles to create distinctive, high-performance web applications that excel in both functionality and user experience.